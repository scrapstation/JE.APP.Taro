//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    getAccountInfo(  cancelToken?: CancelToken | undefined): Promise<AccountInfoResponse> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountInfo(_response);
        });
    }

    protected processGetAccountInfo(response: AxiosResponse): Promise<AccountInfoResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountInfoResponse.fromJS(resultData200);
            return Promise.resolve<AccountInfoResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountInfoResponse>(null as any);
    }
}

export class AuthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    auth(openIdCode: string | null, phoneCode: string | null , cancelToken?: CancelToken | undefined): Promise<WechatAuthResponse> {
        let url_ = this.baseUrl + "/api/Auth/auth?";
        if (openIdCode === undefined)
            throw new Error("The parameter 'openIdCode' must be defined.");
        else if(openIdCode !== null)
            url_ += "openIdCode=" + encodeURIComponent("" + openIdCode) + "&";
        if (phoneCode === undefined)
            throw new Error("The parameter 'phoneCode' must be defined.");
        else if(phoneCode !== null)
            url_ += "phoneCode=" + encodeURIComponent("" + phoneCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuth(_response);
        });
    }

    protected processAuth(response: AxiosResponse): Promise<WechatAuthResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WechatAuthResponse.fromJS(resultData200);
            return Promise.resolve<WechatAuthResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WechatAuthResponse>(null as any);
    }

    authByPhoneCode(code: string | null , cancelToken?: CancelToken | undefined): Promise<WechatAuthResponse> {
        let url_ = this.baseUrl + "/api/Auth/auth-by-code-and-phone?";
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthByPhoneCode(_response);
        });
    }

    protected processAuthByPhoneCode(response: AxiosResponse): Promise<WechatAuthResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WechatAuthResponse.fromJS(resultData200);
            return Promise.resolve<WechatAuthResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WechatAuthResponse>(null as any);
    }

    updateInfo(nickName: string | null, avatarUrl: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/info?";
        if (nickName === undefined)
            throw new Error("The parameter 'nickName' must be defined.");
        else if(nickName !== null)
            url_ += "nickName=" + encodeURIComponent("" + nickName) + "&";
        if (avatarUrl === undefined)
            throw new Error("The parameter 'avatarUrl' must be defined.");
        else if(avatarUrl !== null)
            url_ += "avatarUrl=" + encodeURIComponent("" + avatarUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateInfo(_response);
        });
    }

    protected processUpdateInfo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ConsigneeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    create(req: CreateConsigneeRequest , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Consignee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    modify(req: ModifyConsigneeRequest , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Consignee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    delete(consigneeId: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Consignee?";
        if (consigneeId === undefined || consigneeId === null)
            throw new Error("The parameter 'consigneeId' must be defined and cannot be null.");
        else
            url_ += "consigneeId=" + encodeURIComponent("" + consigneeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<ConsigneeItemResponse[]> {
        let url_ = this.baseUrl + "/api/Consignee/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ConsigneeItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsigneeItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ConsigneeItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConsigneeItemResponse[]>(null as any);
    }

    getById(consigneeId: string , cancelToken?: CancelToken | undefined): Promise<ConsigneeItemResponse> {
        let url_ = this.baseUrl + "/api/Consignee/{consigneeId}";
        if (consigneeId === undefined || consigneeId === null)
            throw new Error("The parameter 'consigneeId' must be defined.");
        url_ = url_.replace("{consigneeId}", encodeURIComponent("" + consigneeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ConsigneeItemResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConsigneeItemResponse.fromJS(resultData200);
            return Promise.resolve<ConsigneeItemResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConsigneeItemResponse>(null as any);
    }

    getRecommended(  cancelToken?: CancelToken | undefined): Promise<ConsigneeItemResponse> {
        let url_ = this.baseUrl + "/api/Consignee/recommended";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecommended(_response);
        });
    }

    protected processGetRecommended(response: AxiosResponse): Promise<ConsigneeItemResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConsigneeItemResponse.fromJS(resultData200);
            return Promise.resolve<ConsigneeItemResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConsigneeItemResponse>(null as any);
    }
}

export class CouponClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    loadCoupon(request: LoadCouponRequest , cancelToken?: CancelToken | undefined): Promise<BaseCouponResponse[]> {
        let url_ = this.baseUrl + "/api/Coupon/load";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoadCoupon(_response);
        });
    }

    protected processLoadCoupon(response: AxiosResponse): Promise<BaseCouponResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BaseCouponResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BaseCouponResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseCouponResponse[]>(null as any);
    }
}

export class OrderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    loadOrder(request: LoadOrderRequest , cancelToken?: CancelToken | undefined): Promise<OrderResponse[]> {
        let url_ = this.baseUrl + "/api/Order/order/load";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoadOrder(_response);
        });
    }

    protected processLoadOrder(response: AxiosResponse): Promise<OrderResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrderResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderResponse[]>(null as any);
    }

    getById(orderId: string , cancelToken?: CancelToken | undefined): Promise<OrderResponse> {
        let url_ = this.baseUrl + "/api/Order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<OrderResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderResponse.fromJS(resultData200);
            return Promise.resolve<OrderResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderResponse>(null as any);
    }

    calculateOrderFee(req: CalculateOrderFeeRequest , cancelToken?: CancelToken | undefined): Promise<CalculateOrderFeeResponse> {
        let url_ = this.baseUrl + "/api/Order/calculate-order-fee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCalculateOrderFee(_response);
        });
    }

    protected processCalculateOrderFee(response: AxiosResponse): Promise<CalculateOrderFeeResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CalculateOrderFeeResponse.fromJS(resultData200);
            return Promise.resolve<CalculateOrderFeeResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CalculateOrderFeeResponse>(null as any);
    }

    getCouponsByOrder(wareFee: number , cancelToken?: CancelToken | undefined): Promise<OrderCouponItemRepsonse[]> {
        let url_ = this.baseUrl + "/api/Order/coupons-by-order?";
        if (wareFee === undefined || wareFee === null)
            throw new Error("The parameter 'wareFee' must be defined and cannot be null.");
        else
            url_ += "wareFee=" + encodeURIComponent("" + wareFee) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCouponsByOrder(_response);
        });
    }

    protected processGetCouponsByOrder(response: AxiosResponse): Promise<OrderCouponItemRepsonse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderCouponItemRepsonse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrderCouponItemRepsonse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderCouponItemRepsonse[]>(null as any);
    }

    create(req: CreateOrderRequest , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    cancel(orderId: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Order?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    pay(orderId: string , cancelToken?: CancelToken | undefined): Promise<PaymentResponse> {
        let url_ = this.baseUrl + "/api/Order/pay?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPay(_response);
        });
    }

    protected processPay(response: AxiosResponse): Promise<PaymentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentResponse.fromJS(resultData200);
            return Promise.resolve<PaymentResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentResponse>(null as any);
    }

    notify(request: TransactionNotifyRequest , cancelToken?: CancelToken | undefined): Promise<TransactionNotifyResponse> {
        let url_ = this.baseUrl + "/api/Order/notify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNotify(_response);
        });
    }

    protected processNotify(response: AxiosResponse): Promise<TransactionNotifyResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransactionNotifyResponse.fromJS(resultData200);
            return Promise.resolve<TransactionNotifyResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionNotifyResponse>(null as any);
    }
}

export class RefundClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    createRefund(request: RefundRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRefund(_response);
        });
    }

    protected processCreateRefund(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getPreviousInfo(orderId: string , cancelToken?: CancelToken | undefined): Promise<GetRefundPreviousInfoResponse> {
        let url_ = this.baseUrl + "/api/Refund/previous_info?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPreviousInfo(_response);
        });
    }

    protected processGetPreviousInfo(response: AxiosResponse): Promise<GetRefundPreviousInfoResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRefundPreviousInfoResponse.fromJS(resultData200);
            return Promise.resolve<GetRefundPreviousInfoResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRefundPreviousInfoResponse>(null as any);
    }
}

export class RiderAccountClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    getSummary(  cancelToken?: CancelToken | undefined): Promise<RiderGetSummaryResponse> {
        let url_ = this.baseUrl + "/api/RiderAccount/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: AxiosResponse): Promise<RiderGetSummaryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RiderGetSummaryResponse.fromJS(resultData200);
            return Promise.resolve<RiderGetSummaryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiderGetSummaryResponse>(null as any);
    }
}

export class RiderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    getSummary(  cancelToken?: CancelToken | undefined): Promise<RiderGetSummaryResponse> {
        let url_ = this.baseUrl + "/api/Rider/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: AxiosResponse): Promise<RiderGetSummaryResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RiderGetSummaryResponse.fromJS(resultData200);
            return Promise.resolve<RiderGetSummaryResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiderGetSummaryResponse>(null as any);
    }

    taskOrder(orderId: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rider/take_order?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTaskOrder(_response);
        });
    }

    protected processTaskOrder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    complateDelivery(deliveryId: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rider/delivery/{deliveryId}/complate";
        if (deliveryId === undefined || deliveryId === null)
            throw new Error("The parameter 'deliveryId' must be defined.");
        url_ = url_.replace("{deliveryId}", encodeURIComponent("" + deliveryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processComplateDelivery(_response);
        });
    }

    protected processComplateDelivery(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAllDeliveringTasks(  cancelToken?: CancelToken | undefined): Promise<RiderDeliveringTasksItemResponse[]> {
        let url_ = this.baseUrl + "/api/Rider/delivering_tasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDeliveringTasks(_response);
        });
    }

    protected processGetAllDeliveringTasks(response: AxiosResponse): Promise<RiderDeliveringTasksItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RiderDeliveringTasksItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RiderDeliveringTasksItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiderDeliveringTasksItemResponse[]>(null as any);
    }

    loadDeliveryHistory(req: LoadRiderDeliveryHistoryRequest , cancelToken?: CancelToken | undefined): Promise<LoadRiderDeliveryHistoryResponse[]> {
        let url_ = this.baseUrl + "/api/Rider/delivering_history/load";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoadDeliveryHistory(_response);
        });
    }

    protected processLoadDeliveryHistory(response: AxiosResponse): Promise<LoadRiderDeliveryHistoryResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LoadRiderDeliveryHistoryResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LoadRiderDeliveryHistoryResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoadRiderDeliveryHistoryResponse[]>(null as any);
    }

    updateLocation(latitude: number, longitude: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Rider?";
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateLocation(_response);
        });
    }

    protected processUpdateLocation(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class StoreClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:4888";

    }

    getStoreById(storeId: string , cancelToken?: CancelToken | undefined): Promise<StoreInfoResponse> {
        let url_ = this.baseUrl + "/api/Store/{storeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStoreById(_response);
        });
    }

    protected processGetStoreById(response: AxiosResponse): Promise<StoreInfoResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StoreInfoResponse.fromJS(resultData200);
            return Promise.resolve<StoreInfoResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StoreInfoResponse>(null as any);
    }
}

export class AccountInfoResponse implements IAccountInfoResponse {
    nickName?: string | undefined;
    avator?: string | undefined;
    phoneNumber?: string | undefined;
    couponCount!: number;
    balance!: number;
    points!: number;
    isRider!: boolean;

    constructor(data?: IAccountInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nickName = _data["nickName"];
            this.avator = _data["avator"];
            this.phoneNumber = _data["phoneNumber"];
            this.couponCount = _data["couponCount"];
            this.balance = _data["balance"];
            this.points = _data["points"];
            this.isRider = _data["isRider"];
        }
    }

    static fromJS(data: any): AccountInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickName"] = this.nickName;
        data["avator"] = this.avator;
        data["phoneNumber"] = this.phoneNumber;
        data["couponCount"] = this.couponCount;
        data["balance"] = this.balance;
        data["points"] = this.points;
        data["isRider"] = this.isRider;
        return data;
    }
}

export interface IAccountInfoResponse {
    nickName?: string | undefined;
    avator?: string | undefined;
    phoneNumber?: string | undefined;
    couponCount: number;
    balance: number;
    points: number;
    isRider: boolean;
}

export class WechatAuthResponse implements IWechatAuthResponse {
    isSuccessful!: boolean;
    msg?: string | undefined;
    token?: string | undefined;
    expiration?: Date | undefined;

    constructor(data?: IWechatAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.msg = _data["msg"];
            this.token = _data["token"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WechatAuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WechatAuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["msg"] = this.msg;
        data["token"] = this.token;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWechatAuthResponse {
    isSuccessful: boolean;
    msg?: string | undefined;
    token?: string | undefined;
    expiration?: Date | undefined;
}

export class CreateConsigneeRequest implements ICreateConsigneeRequest {
    latitude!: number;
    longitude!: number;
    name?: string | undefined;
    mobile?: string | undefined;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    isDefault!: boolean;

    constructor(data?: ICreateConsigneeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.name = _data["name"];
            this.mobile = _data["mobile"];
            this.simpleAddress = _data["simpleAddress"];
            this.fullAddress = _data["fullAddress"];
            this.houseNumber = _data["houseNumber"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateConsigneeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConsigneeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["name"] = this.name;
        data["mobile"] = this.mobile;
        data["simpleAddress"] = this.simpleAddress;
        data["fullAddress"] = this.fullAddress;
        data["houseNumber"] = this.houseNumber;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateConsigneeRequest {
    latitude: number;
    longitude: number;
    name?: string | undefined;
    mobile?: string | undefined;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    isDefault: boolean;
}

export class ModifyConsigneeRequest extends CreateConsigneeRequest implements IModifyConsigneeRequest {
    id!: string;

    constructor(data?: IModifyConsigneeRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModifyConsigneeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ModifyConsigneeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IModifyConsigneeRequest extends ICreateConsigneeRequest {
    id: string;
}

export class ConsigneeItemResponse extends CreateConsigneeRequest implements IConsigneeItemResponse {
    id!: string;

    constructor(data?: IConsigneeItemResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConsigneeItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConsigneeItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IConsigneeItemResponse extends ICreateConsigneeRequest {
    id: string;
}

export class BaseCouponResponse implements IBaseCouponResponse {
    id!: string;
    name?: string | undefined;
    type!: CouponTypeEnumOfCoupon;
    status!: StatusEnumOfCoupon;
    effectiveTimeRange?: string | undefined;
    discountPercent!: number;
    discountMaxAmount!: number;
    discountLimitAmount!: number;
    fullReductionDiscountAmount!: number;
    orderLimitAmount!: number;

    constructor(data?: IBaseCouponResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.effectiveTimeRange = _data["effectiveTimeRange"];
            this.discountPercent = _data["discountPercent"];
            this.discountMaxAmount = _data["discountMaxAmount"];
            this.discountLimitAmount = _data["discountLimitAmount"];
            this.fullReductionDiscountAmount = _data["fullReductionDiscountAmount"];
            this.orderLimitAmount = _data["orderLimitAmount"];
        }
    }

    static fromJS(data: any): BaseCouponResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCouponResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["status"] = this.status;
        data["effectiveTimeRange"] = this.effectiveTimeRange;
        data["discountPercent"] = this.discountPercent;
        data["discountMaxAmount"] = this.discountMaxAmount;
        data["discountLimitAmount"] = this.discountLimitAmount;
        data["fullReductionDiscountAmount"] = this.fullReductionDiscountAmount;
        data["orderLimitAmount"] = this.orderLimitAmount;
        return data;
    }
}

export interface IBaseCouponResponse {
    id: string;
    name?: string | undefined;
    type: CouponTypeEnumOfCoupon;
    status: StatusEnumOfCoupon;
    effectiveTimeRange?: string | undefined;
    discountPercent: number;
    discountMaxAmount: number;
    discountLimitAmount: number;
    fullReductionDiscountAmount: number;
    orderLimitAmount: number;
}

export enum CouponTypeEnumOfCoupon {
    Shipping = "Shipping",
    Discount = "Discount",
    FullReduction = "FullReduction",
}

export enum StatusEnumOfCoupon {
    NotStart = "NotStart",
    Usable = "Usable",
    Used = "Used",
    Expired = "Expired",
}

export class LoadCouponRequest implements ILoadCouponRequest {
    referenceId?: string | undefined;
    statusList?: StatusEnumOfCoupon[] | undefined;

    constructor(data?: ILoadCouponRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceId = _data["referenceId"];
            if (Array.isArray(_data["statusList"])) {
                this.statusList = [] as any;
                for (let item of _data["statusList"])
                    this.statusList!.push(item);
            }
        }
    }

    static fromJS(data: any): LoadCouponRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoadCouponRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        if (Array.isArray(this.statusList)) {
            data["statusList"] = [];
            for (let item of this.statusList)
                data["statusList"].push(item);
        }
        return data;
    }
}

export interface ILoadCouponRequest {
    referenceId?: string | undefined;
    statusList?: StatusEnumOfCoupon[] | undefined;
}

export class AuditFields implements IAuditFields {
    createdOn?: Date | undefined;
    lastModifiedOn?: Date | undefined;

    constructor(data?: IAuditFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.lastModifiedOn = _data["lastModifiedOn"] ? new Date(_data["lastModifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditFields {
        data = typeof data === 'object' ? data : {};
        let result = new AuditFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["lastModifiedOn"] = this.lastModifiedOn ? this.lastModifiedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditFields {
    createdOn?: Date | undefined;
    lastModifiedOn?: Date | undefined;
}

export class OrderResponse extends AuditFields implements IOrderResponse {
    id!: string;
    externalId?: string | undefined;
    amount!: number;
    actualPayment!: number;
    status!: StatusEnumOfOrder;
    orderItems?: OrderItemVoOfOrderResponse[] | undefined;
    expireTime!: Date;
    remark?: string | undefined;

    constructor(data?: IOrderResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.amount = _data["amount"];
            this.actualPayment = _data["actualPayment"];
            this.status = _data["status"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemVoOfOrderResponse.fromJS(item));
            }
            this.expireTime = _data["expireTime"] ? new Date(_data["expireTime"].toString()) : <any>undefined;
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): OrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["amount"] = this.amount;
        data["actualPayment"] = this.actualPayment;
        data["status"] = this.status;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        super.toJSON(data);
        return data;
    }
}

export interface IOrderResponse extends IAuditFields {
    id: string;
    externalId?: string | undefined;
    amount: number;
    actualPayment: number;
    status: StatusEnumOfOrder;
    orderItems?: OrderItemVoOfOrderResponse[] | undefined;
    expireTime: Date;
    remark?: string | undefined;
}

export enum StatusEnumOfOrder {
    PendingPayment = "PendingPayment",
    PendingPack = "PendingPack",
    Packing = "Packing",
    PendingDelivery = "PendingDelivery",
    Delivering = "Delivering",
    Canceled = "Canceled",
    Completed = "Completed",
}

export class OrderItemVoOfOrderResponse implements IOrderItemVoOfOrderResponse {
    snapshotName?: string | undefined;
    imgUrl?: string | undefined;
    price!: number;
    actualPayment!: number;
    quantity!: number;
    snapshotAttributeItemNames?: string | undefined;

    constructor(data?: IOrderItemVoOfOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snapshotName = _data["snapshotName"];
            this.imgUrl = _data["imgUrl"];
            this.price = _data["price"];
            this.actualPayment = _data["actualPayment"];
            this.quantity = _data["quantity"];
            this.snapshotAttributeItemNames = _data["snapshotAttributeItemNames"];
        }
    }

    static fromJS(data: any): OrderItemVoOfOrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemVoOfOrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snapshotName"] = this.snapshotName;
        data["imgUrl"] = this.imgUrl;
        data["price"] = this.price;
        data["actualPayment"] = this.actualPayment;
        data["quantity"] = this.quantity;
        data["snapshotAttributeItemNames"] = this.snapshotAttributeItemNames;
        return data;
    }
}

export interface IOrderItemVoOfOrderResponse {
    snapshotName?: string | undefined;
    imgUrl?: string | undefined;
    price: number;
    actualPayment: number;
    quantity: number;
    snapshotAttributeItemNames?: string | undefined;
}

export class LoadOrderRequest implements ILoadOrderRequest {
    referenceId?: string | undefined;

    constructor(data?: ILoadOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): LoadOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoadOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        return data;
    }
}

export interface ILoadOrderRequest {
    referenceId?: string | undefined;
}

export class CalculateOrderFeeResponse implements ICalculateOrderFeeResponse {
    freeDeliveryPrice!: number;
    wareFee!: number;
    deliveryFee!: number;
    couponDiscountFees?: CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse[] | undefined;
    totalFee!: number;
    availableCouponsCount!: number;

    constructor(data?: ICalculateOrderFeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.freeDeliveryPrice = _data["freeDeliveryPrice"];
            this.wareFee = _data["wareFee"];
            this.deliveryFee = _data["deliveryFee"];
            if (Array.isArray(_data["couponDiscountFees"])) {
                this.couponDiscountFees = [] as any;
                for (let item of _data["couponDiscountFees"])
                    this.couponDiscountFees!.push(CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse.fromJS(item));
            }
            this.totalFee = _data["totalFee"];
            this.availableCouponsCount = _data["availableCouponsCount"];
        }
    }

    static fromJS(data: any): CalculateOrderFeeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CalculateOrderFeeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["freeDeliveryPrice"] = this.freeDeliveryPrice;
        data["wareFee"] = this.wareFee;
        data["deliveryFee"] = this.deliveryFee;
        if (Array.isArray(this.couponDiscountFees)) {
            data["couponDiscountFees"] = [];
            for (let item of this.couponDiscountFees)
                data["couponDiscountFees"].push(item.toJSON());
        }
        data["totalFee"] = this.totalFee;
        data["availableCouponsCount"] = this.availableCouponsCount;
        return data;
    }
}

export interface ICalculateOrderFeeResponse {
    freeDeliveryPrice: number;
    wareFee: number;
    deliveryFee: number;
    couponDiscountFees?: CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse[] | undefined;
    totalFee: number;
    availableCouponsCount: number;
}

export class CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse implements ICouponDiscountFeeOfTypesOfCalculateOrderFeeResponse {
    couponId!: string;
    name?: string | undefined;
    discountFee!: number;

    constructor(data?: ICouponDiscountFeeOfTypesOfCalculateOrderFeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponId = _data["couponId"];
            this.name = _data["name"];
            this.discountFee = _data["discountFee"];
        }
    }

    static fromJS(data: any): CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDiscountFeeOfTypesOfCalculateOrderFeeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponId"] = this.couponId;
        data["name"] = this.name;
        data["discountFee"] = this.discountFee;
        return data;
    }
}

export interface ICouponDiscountFeeOfTypesOfCalculateOrderFeeResponse {
    couponId: string;
    name?: string | undefined;
    discountFee: number;
}

export class CalculateOrderFeeRequest implements ICalculateOrderFeeRequest {
    orderItems?: ItemOfCalculateOrderFeeRequest[] | undefined;
    couponIds?: string[] | undefined;

    constructor(data?: ICalculateOrderFeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(ItemOfCalculateOrderFeeRequest.fromJS(item));
            }
            if (Array.isArray(_data["couponIds"])) {
                this.couponIds = [] as any;
                for (let item of _data["couponIds"])
                    this.couponIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CalculateOrderFeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CalculateOrderFeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        if (Array.isArray(this.couponIds)) {
            data["couponIds"] = [];
            for (let item of this.couponIds)
                data["couponIds"].push(item);
        }
        return data;
    }
}

export interface ICalculateOrderFeeRequest {
    orderItems?: ItemOfCalculateOrderFeeRequest[] | undefined;
    couponIds?: string[] | undefined;
}

export class ItemOfCalculateOrderFeeRequest implements IItemOfCalculateOrderFeeRequest {
    skuId!: string;
    quantity!: number;

    constructor(data?: IItemOfCalculateOrderFeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): ItemOfCalculateOrderFeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ItemOfCalculateOrderFeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IItemOfCalculateOrderFeeRequest {
    skuId: string;
    quantity: number;
}

export class OrderCouponItemRepsonse extends BaseCouponResponse implements IOrderCouponItemRepsonse {
    available!: boolean;
    unavailableReasons?: string[] | undefined;

    constructor(data?: IOrderCouponItemRepsonse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.available = _data["available"];
            if (Array.isArray(_data["unavailableReasons"])) {
                this.unavailableReasons = [] as any;
                for (let item of _data["unavailableReasons"])
                    this.unavailableReasons!.push(item);
            }
        }
    }

    static fromJS(data: any): OrderCouponItemRepsonse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCouponItemRepsonse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["available"] = this.available;
        if (Array.isArray(this.unavailableReasons)) {
            data["unavailableReasons"] = [];
            for (let item of this.unavailableReasons)
                data["unavailableReasons"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOrderCouponItemRepsonse extends IBaseCouponResponse {
    available: boolean;
    unavailableReasons?: string[] | undefined;
}

export class CreateOrderRequest implements ICreateOrderRequest {
    createOrderItems?: ItemOfCreateOrderRequest[] | undefined;
    couponIds?: string[] | undefined;
    consigneeId!: string;
    remark?: string | undefined;

    constructor(data?: ICreateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["createOrderItems"])) {
                this.createOrderItems = [] as any;
                for (let item of _data["createOrderItems"])
                    this.createOrderItems!.push(ItemOfCreateOrderRequest.fromJS(item));
            }
            if (Array.isArray(_data["couponIds"])) {
                this.couponIds = [] as any;
                for (let item of _data["couponIds"])
                    this.couponIds!.push(item);
            }
            this.consigneeId = _data["consigneeId"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): CreateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.createOrderItems)) {
            data["createOrderItems"] = [];
            for (let item of this.createOrderItems)
                data["createOrderItems"].push(item.toJSON());
        }
        if (Array.isArray(this.couponIds)) {
            data["couponIds"] = [];
            for (let item of this.couponIds)
                data["couponIds"].push(item);
        }
        data["consigneeId"] = this.consigneeId;
        data["remark"] = this.remark;
        return data;
    }
}

export interface ICreateOrderRequest {
    createOrderItems?: ItemOfCreateOrderRequest[] | undefined;
    couponIds?: string[] | undefined;
    consigneeId: string;
    remark?: string | undefined;
}

export class ItemOfCreateOrderRequest implements IItemOfCreateOrderRequest {
    skuId!: string;
    quantity!: number;

    constructor(data?: IItemOfCreateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): ItemOfCreateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ItemOfCreateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IItemOfCreateOrderRequest {
    skuId: string;
    quantity: number;
}

export class PaymentResponse implements IPaymentResponse {
    orderId!: string;
    timeStamp?: string | undefined;
    nonceStr?: string | undefined;
    package?: string | undefined;
    signType?: string | undefined;
    paySign?: string | undefined;

    constructor(data?: IPaymentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.timeStamp = _data["timeStamp"];
            this.nonceStr = _data["nonceStr"];
            this.package = _data["package"];
            this.signType = _data["signType"];
            this.paySign = _data["paySign"];
        }
    }

    static fromJS(data: any): PaymentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["timeStamp"] = this.timeStamp;
        data["nonceStr"] = this.nonceStr;
        data["package"] = this.package;
        data["signType"] = this.signType;
        data["paySign"] = this.paySign;
        return data;
    }
}

export interface IPaymentResponse {
    orderId: string;
    timeStamp?: string | undefined;
    nonceStr?: string | undefined;
    package?: string | undefined;
    signType?: string | undefined;
    paySign?: string | undefined;
}

export class TransactionNotifyResponse implements ITransactionNotifyResponse {
    code!: CodeEnumOfTransactionNotifyResponse;
    message?: string | undefined;

    constructor(data?: ITransactionNotifyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): TransactionNotifyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionNotifyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface ITransactionNotifyResponse {
    code: CodeEnumOfTransactionNotifyResponse;
    message?: string | undefined;
}

export enum CodeEnumOfTransactionNotifyResponse {
    SUCCESS = "SUCCESS",
    FAILURE = "FAILURE",
}

export class TransactionNotifyRequest implements ITransactionNotifyRequest {
    id?: string | undefined;
    create_time!: Date;
    resource_type?: string | undefined;
    event_type?: string | undefined;
    resource?: TransactionNotifyResourceOfTransactionNotifyRequest | undefined;
    summary?: string | undefined;

    constructor(data?: ITransactionNotifyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.create_time = _data["create_time"] ? new Date(_data["create_time"].toString()) : <any>undefined;
            this.resource_type = _data["resource_type"];
            this.event_type = _data["event_type"];
            this.resource = _data["resource"] ? TransactionNotifyResourceOfTransactionNotifyRequest.fromJS(_data["resource"]) : <any>undefined;
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): TransactionNotifyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionNotifyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["create_time"] = this.create_time ? this.create_time.toISOString() : <any>undefined;
        data["resource_type"] = this.resource_type;
        data["event_type"] = this.event_type;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["summary"] = this.summary;
        return data;
    }
}

export interface ITransactionNotifyRequest {
    id?: string | undefined;
    create_time: Date;
    resource_type?: string | undefined;
    event_type?: string | undefined;
    resource?: TransactionNotifyResourceOfTransactionNotifyRequest | undefined;
    summary?: string | undefined;
}

export class TransactionNotifyResourceOfTransactionNotifyRequest implements ITransactionNotifyResourceOfTransactionNotifyRequest {
    algorithm?: string | undefined;
    ciphertext?: string | undefined;
    associated_data?: string | undefined;
    original_type?: string | undefined;
    nonce?: string | undefined;

    constructor(data?: ITransactionNotifyResourceOfTransactionNotifyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.algorithm = _data["algorithm"];
            this.ciphertext = _data["ciphertext"];
            this.associated_data = _data["associated_data"];
            this.original_type = _data["original_type"];
            this.nonce = _data["nonce"];
        }
    }

    static fromJS(data: any): TransactionNotifyResourceOfTransactionNotifyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionNotifyResourceOfTransactionNotifyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["algorithm"] = this.algorithm;
        data["ciphertext"] = this.ciphertext;
        data["associated_data"] = this.associated_data;
        data["original_type"] = this.original_type;
        data["nonce"] = this.nonce;
        return data;
    }
}

export interface ITransactionNotifyResourceOfTransactionNotifyRequest {
    algorithm?: string | undefined;
    ciphertext?: string | undefined;
    associated_data?: string | undefined;
    original_type?: string | undefined;
    nonce?: string | undefined;
}

export class RefundRequest implements IRefundRequest {
    orderId!: string;
    refundType!: RefundTypeEnumOfRefundRequest;
    reasonType!: ReasonTypeEnumOfRefund;
    reasonDescription?: string | undefined;
    refundDeliveryFee!: number;
    refundOrderItems?: RefundOrderItemOfTypesOfRefundRequest[] | undefined;

    constructor(data?: IRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.refundType = _data["refundType"];
            this.reasonType = _data["reasonType"];
            this.reasonDescription = _data["reasonDescription"];
            this.refundDeliveryFee = _data["refundDeliveryFee"];
            if (Array.isArray(_data["refundOrderItems"])) {
                this.refundOrderItems = [] as any;
                for (let item of _data["refundOrderItems"])
                    this.refundOrderItems!.push(RefundOrderItemOfTypesOfRefundRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["refundType"] = this.refundType;
        data["reasonType"] = this.reasonType;
        data["reasonDescription"] = this.reasonDescription;
        data["refundDeliveryFee"] = this.refundDeliveryFee;
        if (Array.isArray(this.refundOrderItems)) {
            data["refundOrderItems"] = [];
            for (let item of this.refundOrderItems)
                data["refundOrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRefundRequest {
    orderId: string;
    refundType: RefundTypeEnumOfRefundRequest;
    reasonType: ReasonTypeEnumOfRefund;
    reasonDescription?: string | undefined;
    refundDeliveryFee: number;
    refundOrderItems?: RefundOrderItemOfTypesOfRefundRequest[] | undefined;
}

export enum RefundTypeEnumOfRefundRequest {
    Full = "Full",
    Partial = "Partial",
}

export enum ReasonTypeEnumOfRefund {
    BuyTheWrong = "BuyTheWrong",
    QualityProblem = "QualityProblem",
    NotReceived = "NotReceived",
    Others = "Others",
}

export class RefundOrderItemOfTypesOfRefundRequest implements IRefundOrderItemOfTypesOfRefundRequest {
    orderItemId!: string;
    quantity!: number;
    amount!: number;

    constructor(data?: IRefundOrderItemOfTypesOfRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderItemId = _data["orderItemId"];
            this.quantity = _data["quantity"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): RefundOrderItemOfTypesOfRefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefundOrderItemOfTypesOfRefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IRefundOrderItemOfTypesOfRefundRequest {
    orderItemId: string;
    quantity: number;
    amount: number;
}

export class GetRefundPreviousInfoResponse implements IGetRefundPreviousInfoResponse {
    orderItems?: OrderItemOfTypesOfGetRefundPreviousInfoResponse[] | undefined;
    maxRefundAmount!: number;
    deliveryFee!: number;

    constructor(data?: IGetRefundPreviousInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemOfTypesOfGetRefundPreviousInfoResponse.fromJS(item));
            }
            this.maxRefundAmount = _data["maxRefundAmount"];
            this.deliveryFee = _data["deliveryFee"];
        }
    }

    static fromJS(data: any): GetRefundPreviousInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetRefundPreviousInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["maxRefundAmount"] = this.maxRefundAmount;
        data["deliveryFee"] = this.deliveryFee;
        return data;
    }
}

export interface IGetRefundPreviousInfoResponse {
    orderItems?: OrderItemOfTypesOfGetRefundPreviousInfoResponse[] | undefined;
    maxRefundAmount: number;
    deliveryFee: number;
}

export class OrderItemOfTypesOfGetRefundPreviousInfoResponse implements IOrderItemOfTypesOfGetRefundPreviousInfoResponse {
    refundedQuantity!: number;
    price!: number;
    discountAmount!: number;
    quantity!: number;
    snapshotName?: string | undefined;
    imageUrl?: string | undefined;
    snapshotAttributeItemNames?: string | undefined;

    constructor(data?: IOrderItemOfTypesOfGetRefundPreviousInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refundedQuantity = _data["refundedQuantity"];
            this.price = _data["price"];
            this.discountAmount = _data["discountAmount"];
            this.quantity = _data["quantity"];
            this.snapshotName = _data["snapshotName"];
            this.imageUrl = _data["imageUrl"];
            this.snapshotAttributeItemNames = _data["snapshotAttributeItemNames"];
        }
    }

    static fromJS(data: any): OrderItemOfTypesOfGetRefundPreviousInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemOfTypesOfGetRefundPreviousInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refundedQuantity"] = this.refundedQuantity;
        data["price"] = this.price;
        data["discountAmount"] = this.discountAmount;
        data["quantity"] = this.quantity;
        data["snapshotName"] = this.snapshotName;
        data["imageUrl"] = this.imageUrl;
        data["snapshotAttributeItemNames"] = this.snapshotAttributeItemNames;
        return data;
    }
}

export interface IOrderItemOfTypesOfGetRefundPreviousInfoResponse {
    refundedQuantity: number;
    price: number;
    discountAmount: number;
    quantity: number;
    snapshotName?: string | undefined;
    imageUrl?: string | undefined;
    snapshotAttributeItemNames?: string | undefined;
}

export class RiderGetSummaryResponse implements IRiderGetSummaryResponse {
    todayTaskCount!: number;
    todayExpectedIncome!: number;
    totalIncome!: number;
    balance!: number;

    constructor(data?: IRiderGetSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.todayTaskCount = _data["todayTaskCount"];
            this.todayExpectedIncome = _data["todayExpectedIncome"];
            this.totalIncome = _data["totalIncome"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): RiderGetSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RiderGetSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todayTaskCount"] = this.todayTaskCount;
        data["todayExpectedIncome"] = this.todayExpectedIncome;
        data["totalIncome"] = this.totalIncome;
        data["balance"] = this.balance;
        return data;
    }
}

export interface IRiderGetSummaryResponse {
    todayTaskCount: number;
    todayExpectedIncome: number;
    totalIncome: number;
    balance: number;
}

export class RiderDeliveringTasksItemResponse implements IRiderDeliveringTasksItemResponse {
    id!: string;
    orderCreateTime!: Date;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    name?: string | undefined;
    mobile?: string | undefined;
    status!: DeliveryStatusEnumOfDeliveryHistory;

    constructor(data?: IRiderDeliveringTasksItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderCreateTime = _data["orderCreateTime"] ? new Date(_data["orderCreateTime"].toString()) : <any>undefined;
            this.simpleAddress = _data["simpleAddress"];
            this.fullAddress = _data["fullAddress"];
            this.houseNumber = _data["houseNumber"];
            this.name = _data["name"];
            this.mobile = _data["mobile"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RiderDeliveringTasksItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RiderDeliveringTasksItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderCreateTime"] = this.orderCreateTime ? this.orderCreateTime.toISOString() : <any>undefined;
        data["simpleAddress"] = this.simpleAddress;
        data["fullAddress"] = this.fullAddress;
        data["houseNumber"] = this.houseNumber;
        data["name"] = this.name;
        data["mobile"] = this.mobile;
        data["status"] = this.status;
        return data;
    }
}

export interface IRiderDeliveringTasksItemResponse {
    id: string;
    orderCreateTime: Date;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    name?: string | undefined;
    mobile?: string | undefined;
    status: DeliveryStatusEnumOfDeliveryHistory;
}

export enum DeliveryStatusEnumOfDeliveryHistory {
    InDelivery = "InDelivery",
    Transferred = "Transferred",
    Canceled = "Canceled",
    Complated = "Complated",
}

export class LoadRiderDeliveryHistoryResponse implements ILoadRiderDeliveryHistoryResponse {
    id!: string;
    orderId!: string;
    status!: DeliveryStatusEnumOfDeliveryHistory;
    name?: string | undefined;
    mobile?: string | undefined;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    commission!: number;
    settledCommission?: number | undefined;
    settledTime?: Date | undefined;
    createdOn!: Date;

    constructor(data?: ILoadRiderDeliveryHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderId = _data["orderId"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.mobile = _data["mobile"];
            this.simpleAddress = _data["simpleAddress"];
            this.fullAddress = _data["fullAddress"];
            this.houseNumber = _data["houseNumber"];
            this.commission = _data["commission"];
            this.settledCommission = _data["settledCommission"];
            this.settledTime = _data["settledTime"] ? new Date(_data["settledTime"].toString()) : <any>undefined;
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LoadRiderDeliveryHistoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoadRiderDeliveryHistoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        data["name"] = this.name;
        data["mobile"] = this.mobile;
        data["simpleAddress"] = this.simpleAddress;
        data["fullAddress"] = this.fullAddress;
        data["houseNumber"] = this.houseNumber;
        data["commission"] = this.commission;
        data["settledCommission"] = this.settledCommission;
        data["settledTime"] = this.settledTime ? this.settledTime.toISOString() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILoadRiderDeliveryHistoryResponse {
    id: string;
    orderId: string;
    status: DeliveryStatusEnumOfDeliveryHistory;
    name?: string | undefined;
    mobile?: string | undefined;
    simpleAddress?: string | undefined;
    fullAddress?: string | undefined;
    houseNumber?: string | undefined;
    commission: number;
    settledCommission?: number | undefined;
    settledTime?: Date | undefined;
    createdOn: Date;
}

export class LoadRiderDeliveryHistoryRequest implements ILoadRiderDeliveryHistoryRequest {
    referenceId?: string | undefined;
    startTime!: Date;
    endTime!: Date;
    isDisputed!: boolean;

    constructor(data?: ILoadRiderDeliveryHistoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceId = _data["referenceId"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.isDisputed = _data["isDisputed"];
        }
    }

    static fromJS(data: any): LoadRiderDeliveryHistoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoadRiderDeliveryHistoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceId"] = this.referenceId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["isDisputed"] = this.isDisputed;
        return data;
    }
}

export interface ILoadRiderDeliveryHistoryRequest {
    referenceId?: string | undefined;
    startTime: Date;
    endTime: Date;
    isDisputed: boolean;
}

export class StoreInfoResponse implements IStoreInfoResponse {
    baseInfo?: BaseInfoVoOfStoreInfoResponse | undefined;
    categoryInfo?: CategoryInfoVoOfStoreInfoResponse[] | undefined;

    constructor(data?: IStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseInfo = _data["baseInfo"] ? BaseInfoVoOfStoreInfoResponse.fromJS(_data["baseInfo"]) : <any>undefined;
            if (Array.isArray(_data["categoryInfo"])) {
                this.categoryInfo = [] as any;
                for (let item of _data["categoryInfo"])
                    this.categoryInfo!.push(CategoryInfoVoOfStoreInfoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseInfo"] = this.baseInfo ? this.baseInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.categoryInfo)) {
            data["categoryInfo"] = [];
            for (let item of this.categoryInfo)
                data["categoryInfo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStoreInfoResponse {
    baseInfo?: BaseInfoVoOfStoreInfoResponse | undefined;
    categoryInfo?: CategoryInfoVoOfStoreInfoResponse[] | undefined;
}

export class BaseInfoVoOfStoreInfoResponse implements IBaseInfoVoOfStoreInfoResponse {
    id!: string;
    name?: string | undefined;
    no?: string | undefined;
    autoStartTime!: string;
    autoCloseTime!: string;
    status!: StatusEnumOfStore;
    freeDeliveryPrice!: number;
    latitude!: number;
    longitude!: number;

    constructor(data?: IBaseInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.no = _data["no"];
            this.autoStartTime = _data["autoStartTime"];
            this.autoCloseTime = _data["autoCloseTime"];
            this.status = _data["status"];
            this.freeDeliveryPrice = _data["freeDeliveryPrice"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): BaseInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BaseInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["no"] = this.no;
        data["autoStartTime"] = this.autoStartTime;
        data["autoCloseTime"] = this.autoCloseTime;
        data["status"] = this.status;
        data["freeDeliveryPrice"] = this.freeDeliveryPrice;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IBaseInfoVoOfStoreInfoResponse {
    id: string;
    name?: string | undefined;
    no?: string | undefined;
    autoStartTime: string;
    autoCloseTime: string;
    status: StatusEnumOfStore;
    freeDeliveryPrice: number;
    latitude: number;
    longitude: number;
}

export enum StatusEnumOfStore {
    Open = "Open",
    Closed = "Closed",
}

export class CategoryInfoVoOfStoreInfoResponse implements ICategoryInfoVoOfStoreInfoResponse {
    id!: string;
    name?: string | undefined;
    products?: ProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;

    constructor(data?: ICategoryInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductOfCategoryInfoVoOfStoreInfoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryInfoVoOfStoreInfoResponse {
    id: string;
    name?: string | undefined;
    products?: ProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;
}

export class ProductOfCategoryInfoVoOfStoreInfoResponse implements IProductOfCategoryInfoVoOfStoreInfoResponse {
    id!: string;
    name?: string | undefined;
    price!: number;
    imgUrl?: string | undefined;
    description?: string | undefined;
    isMultiSku!: boolean;
    attributes?: AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;
    skus?: SkuOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;

    constructor(data?: IProductOfCategoryInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.imgUrl = _data["imgUrl"];
            this.description = _data["description"];
            this.isMultiSku = _data["isMultiSku"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse.fromJS(item));
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuOfProductOfCategoryInfoVoOfStoreInfoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOfCategoryInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOfCategoryInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["imgUrl"] = this.imgUrl;
        data["description"] = this.description;
        data["isMultiSku"] = this.isMultiSku;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductOfCategoryInfoVoOfStoreInfoResponse {
    id: string;
    name?: string | undefined;
    price: number;
    imgUrl?: string | undefined;
    description?: string | undefined;
    isMultiSku: boolean;
    attributes?: AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;
    skus?: SkuOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;
}

export class AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse implements IAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id!: string;
    name?: string | undefined;
    attributeItems?: ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;

    constructor(data?: IAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["attributeItems"])) {
                this.attributeItems = [] as any;
                for (let item of _data["attributeItems"])
                    this.attributeItems!.push(ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeOfProductOfCategoryInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.attributeItems)) {
            data["attributeItems"] = [];
            for (let item of this.attributeItems)
                data["attributeItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id: string;
    name?: string | undefined;
    attributeItems?: ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse[] | undefined;
}

export class ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse implements IItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id!: string;
    name?: string | undefined;

    constructor(data?: IItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IItemOfAttributeOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id: string;
    name?: string | undefined;
}

export class SkuOfProductOfCategoryInfoVoOfStoreInfoResponse implements ISkuOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id!: string;
    price!: number;
    inventory!: number;
    attributeItemIds?: string[] | undefined;

    constructor(data?: ISkuOfProductOfCategoryInfoVoOfStoreInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            if (Array.isArray(_data["attributeItemIds"])) {
                this.attributeItemIds = [] as any;
                for (let item of _data["attributeItemIds"])
                    this.attributeItemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SkuOfProductOfCategoryInfoVoOfStoreInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SkuOfProductOfCategoryInfoVoOfStoreInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        if (Array.isArray(this.attributeItemIds)) {
            data["attributeItemIds"] = [];
            for (let item of this.attributeItemIds)
                data["attributeItemIds"].push(item);
        }
        return data;
    }
}

export interface ISkuOfProductOfCategoryInfoVoOfStoreInfoResponse {
    id: string;
    price: number;
    inventory: number;
    attributeItemIds?: string[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}